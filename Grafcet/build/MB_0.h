/* File generated by Beremiz (PlugGenerate_C method of modbus Plugin instance) */

/*
 * Copyright (c) 2016 Mario de Sousa (msousa@fe.up.pt)
 *
 * This file is part of the Modbus library for Beremiz and matiec.
 *
 * This Modbus library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser 
 * General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this Modbus library.  If not, see <http://www.gnu.org/licenses/>.
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 */

#include "mb_addr.h"
#include "mb_tcp_private.h"
#include "mb_master_private.h"



#define DEF_REQ_SEND_RETRIES 0

  // Used by the Modbus server node
#define MEM_AREA_SIZE 65536
typedef struct{
	    u16		ro_bits [MEM_AREA_SIZE];
	    u16		rw_bits [MEM_AREA_SIZE];
	    u16		ro_words[MEM_AREA_SIZE];
	    u16		rw_words[MEM_AREA_SIZE];
	} server_mem_t;

typedef struct{
	    const char *location;
	    u8		slave_id;
	    node_addr_t	node_address;
	    int		mb_nd;      // modbus library node used for this server 
	    int		init_state; // store how far along the server's initialization has progressed
	    pthread_t	thread_id;  // thread handling this server
	    server_mem_t	mem_area;
	} server_node_t;


  // Used by the Modbus client node
typedef struct{
	    const char *location;
	    node_addr_t	node_address;
	    int		mb_nd;
	    int		init_state; // store how far along the client's initialization has progressed
	    u64		comm_period;
	    int		prev_error; // error code of the last printed error message (0 when no error) 
	    pthread_t	thread_id;  // thread handling all communication with this client
	} client_node_t;


  // Used by the Modbus client plugin
typedef enum {
	    req_input,
	    req_output,
	    no_request		/* just for tests to quickly disable a request */
	} iotype_t;

#define REQ_BUF_SIZE 2000
typedef struct{
	    const char *location;
	    int		client_node_id;
	    u8		slave_id;
	    iotype_t	req_type;
	    u8		mb_function;
	    u16		address;
	    u16		count;
	    int		retries;
	    u8		error_code; // modbus error code (if any) of current request
	    int		prev_error; // error code of the last printed error message (0 when no error) 
	    struct timespec resp_timeout;
	      // buffer used to store located PLC variables
	    u16		plcv_buffer[REQ_BUF_SIZE];
	      // buffer used to store data coming from / going to server
	    u16		coms_buffer[REQ_BUF_SIZE]; 
	    pthread_mutex_t coms_buf_mutex; // mutex to access coms_buffer[]
	} client_request_t;


/* The total number of nodes, needed to support _all_ instances of the modbus plugin */
#define TOTAL_TCPNODE_COUNT       11
#define TOTAL_RTUNODE_COUNT       0
#define TOTAL_ASCNODE_COUNT       0

/* Values for instance 0 of the modbus plugin */
#define MAX_NUMBER_OF_TCPCLIENTS  10

#define NUMBER_OF_TCPSERVER_NODES 0
#define NUMBER_OF_TCPCLIENT_NODES 1
#define NUMBER_OF_TCPCLIENT_REQTS 2

#define NUMBER_OF_RTUSERVER_NODES 0
#define NUMBER_OF_RTUCLIENT_NODES 0
#define NUMBER_OF_RTUCLIENT_REQTS 0

#define NUMBER_OF_ASCIISERVER_NODES 0
#define NUMBER_OF_ASCIICLIENT_NODES 0
#define NUMBER_OF_ASCIICLIENT_REQTS 0

#define NUMBER_OF_SERVER_NODES (NUMBER_OF_TCPSERVER_NODES + \
                                NUMBER_OF_RTUSERVER_NODES + \
                                NUMBER_OF_ASCIISERVER_NODES)

#define NUMBER_OF_CLIENT_NODES (NUMBER_OF_TCPCLIENT_NODES + \
                                NUMBER_OF_RTUCLIENT_NODES + \
                                NUMBER_OF_ASCIICLIENT_NODES)

#define NUMBER_OF_CLIENT_REQTS (NUMBER_OF_TCPCLIENT_REQTS + \
                                NUMBER_OF_RTUCLIENT_REQTS + \
                                NUMBER_OF_ASCIICLIENT_REQTS)


/*initialization following all parameters given by user in application*/

static client_node_t		client_nodes[NUMBER_OF_CLIENT_NODES] = {
/*node 0.0*/
{"0.0", {naf_tcp, {.tcp = {"localhost", "5502", DEF_CLOSE_ON_SILENCE}}}, -1 /* mb_nd */, 0 /* init_state */, 100 /* communication period */, 0 /* prev_error */}
};


static client_request_t	client_requests[NUMBER_OF_CLIENT_REQTS] = {
/*request 0_0_0*/
{"0_0_0", 0, 1, req_input, 2, 0 , 3,
DEF_REQ_SEND_RETRIES, 0 /* error_code */, 0 /* prev_code */, {0, 10000000} /* timeout */,
{0,0,0}, {0,0,0}},

/*request 0_0_1*/
{"0_0_1", 0, 1, req_output, 15, 0 , 6,
DEF_REQ_SEND_RETRIES, 0 /* error_code */, 0 /* prev_code */, {0, 10000000} /* timeout */,
{0,0,0,0,0,0}, {0,0,0,0,0,0}}
};


static server_node_t		server_nodes[NUMBER_OF_SERVER_NODES] = {

}
;

/*******************/
/*located variables*/
/*******************/

u16 *__IX0_0_0_0 = &client_requests[0].plcv_buffer[0];
u16 *__IX0_0_0_1 = &client_requests[0].plcv_buffer[1];
u16 *__IX0_0_0_2 = &client_requests[0].plcv_buffer[2];
u16 *__QX0_0_1_0 = &client_requests[1].plcv_buffer[0];
u16 *__QX0_0_1_1 = &client_requests[1].plcv_buffer[1];
u16 *__QX0_0_1_2 = &client_requests[1].plcv_buffer[2];
u16 *__QX0_0_1_3 = &client_requests[1].plcv_buffer[3];
u16 *__QX0_0_1_4 = &client_requests[1].plcv_buffer[4];
u16 *__QX0_0_1_5 = &client_requests[1].plcv_buffer[5];

